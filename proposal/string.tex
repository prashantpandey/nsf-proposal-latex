\section{String data structures}

%
String pattern matching is one of the most common and most computationally intensive problem in computational biology.
%
String pattern matching is the problem of counting or locating occurrences of a query text pattern $P$ within a large database text $T$. While not limited to the analysis of biological sequences, string pattern matching is integral to many tasks in computational biology, including mapping sequence reads to a reference genome~\cite{li2009fast,langmead2009ultrafast}, sequence to graph alignment~\cite{Jain2020}, taxonomic classification~\cite{menzel2016fast,kim2016centrifuge}, sequencing error correction~\cite{huang2017efficient}, and seeding for sequence alignments~\cite{buchfink2015fast,altschul1990basic,steinegger2017mmseqs2}.

The need for high-throughput pattern matching in computational biology has motivated numerous approaches including hashing, lookup tables, suffix arrays~\cite{manber1993suffix}, and compressed suffix array data structures such as the FM-index~\cite{ferragina2000opportunistic}, BOSS~\cite{Muggli2019} and positional-BWT~\cite{Durbin2014}. 
FM-index is based on Burrows-Wheeler transform~\cite{burrows1994block}. The Burrows-Wheeler transform (BWT) is a reversible text transform that was originally proposed for lossless data compression.

% Strings and subsequences appear in a plethora of computational biology problems because the basic types of DNA, RNA, and protein molecules can be represented as stringsâ€”pieces over a given alphabet of DNA as strings over the alphabet {A,C, G, T } (representing the four bases adenine, cytosine, guanine, and thymine, respectively), pieces of RNA as strings over the alphabet {A,C, G, U} (with uracil replacing thymine) and proteins as strings over an alphabet of 20, corresponding to the 20 amino acid residues.

% Let $A$ be a finite alphabet consisting of a set of characters (or symbols).  The cardinality of the alphabet denoted by $|A|$ expresses the number of distinct characters in the alphabet.  A string or word is an ordered list of zero or more characters drawn from the alphabet. A word or string $w$ of length $n$ is represented by $w[1 \ldots n] = w[1],w[2], \ldots ,w[n]$, where $w[i] \in A \; for \; 1 \leq i \leq n$ and $|w|$ denotes the length of $w$. The empty word is the empty sequence (of zero length) and is denoted by $\phi$.  A list of characters of $w$, appearing in consecutive positions, is called a \emph{substring} of $w$, denoted by $w[i \ldots j]$, where $i$ and $j$ are the starting and ending positions, respectively. If the substring starts at position 1, then it is called a \emph{prefix}, whereas if it ends at position $n$, then it is called a \emph{suffix} of $w$. However, an ordered list of characters of $w$ that are not necessarily consecutive is called a \emph{subsequence} of $w$.

Use of the FM-index across applications is due to its fast performance and low memory footprint. Unfortunately, its adoption is likely limited by the lack of an optimized and lightweight FM-index library; the only robust, currently maintained FM-index implementations are SeqAn3 library~\cite{Reinert2017} and AWFM-index~\cite{Anderson2021}.

FM-index is a static data structure. It saves space at the cost of updability. However, sequences are often added and deleted in computational biology datasets and existing applications have to rebuild the string indexes from scratch to support updability. 
%
Constructing compressed string indexes like BWT and FM-index is memory intensive. Existing tools like BOSS~\cite{Bowe2012} and VARI~\cite{Muggli2019} use disks to mitigate the high memory requirements to construct string index. They need to write out the intermediate results to disk and page them back and forth. This results in suboptimal construction speed.
%
Furthermore, so far GPUs are not utilized to scale up sequence-to-sequence alignment and sequence-to-graph alignment. Existing data structures are designed for single-node CPUs. Also, sequence-to-graph alignment algorithms do not scale out to distributed memory to support large-scale pangenomics graphs.

\begin{rproblem}
Build theoretical algorithms to support adding and deleting strings in an FM-index.
\label{rpob:dynamic-fmindex}
\end{rproblem}

\begin{rproblem}
Build a GPU-implementation of the dynamic FM-index.
\label{rpob:gpu-fmindex}
\end{rproblem}

\begin{rproblem}
Extend FM-index and P-BWT to GPUs to accelerate sequence alignment.
\end{rproblem}

\begin{rproblem}
Design and build a sequence-to-sequence and sequence-to-graph alignment library for GPUs.
\end{rproblem}


\begin{rproblem}
Design and build a sequence to graph alignment library for GPUs in distributed-memory when the sequence graph is stored across multiple GPUs.
\end{rproblem}

\paragraph{Proposed approach.}
We plan to extend FM-index and P-BWT data structures using the a new framework for dynamic data structures for string processing~\cite{Nicola17,Farzan2011}. Our plan is to make the underlying bit vector representation dynamic and support efficient rank and select queries on dynamic bit vectors~\cite{}

